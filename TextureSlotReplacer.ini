namespace = TSR

; Texture Slot Replacer - Genshin - Version 0.98
; If you find any bugs, please report them to Caverabbit on the AGMG discord!

; Functions ----------------------------

[CommandListSetTextures]
; if ps == 1718

	ps-t100 = ref ResourceDiffuse
	ps-t101 = ref ResourceLightmap
	ps-t102 = ref ResourceNormalmap
	ps-t103 = ref ResourceNataFXOutline
	ps-t103 = ref ResourceNatlanGlow unless_null
	ps-t104 = ref ResourceNataFXmap
	ps-t104 = ref ResourceNatlanTattoo unless_null

; endif

ResourceDiffuse = null
ResourceLightmap = null
ResourceNormalmap = null
ResourceNataFXOutline = null
ResourceNataFXmap = null

ResourceNatlanGlow = null
ResourceNatlanTattoo = null

[CommandListClear]
ps-t100 = null
ps-t101 = null
ps-t102 = null
ps-t103 = null
ps-t104 = null

ResourceDiffuse = null
ResourceLightmap = null
ResourceNormalmap = null
ResourceNataFXOutline = null
ResourceNormalmap = null

ResourceNatlanGlow = null
ResourceNatlanTattoo = null

[Present]
ResourceDiffuse = null
ResourceLightmap = null
ResourceNormalmap = null
ResourceNataFXOutline = null
ResourceNormalmap = null

ResourceNatlanGlow = null
ResourceNatlanTattoo = null

; Resource -----------------------------

[ResourceDiffuse]
[ResourceLightmap]
[ResourceNormalmap]
[ResourceNataFXOutline]
[ResourceNataFXmap]

[ResourceNatlanGlow]
[ResourceNatlanTattoo]

; TSR ----------------------------------

[ShaderRegexMain]
shader_model = ps_4_0 ps_5_0
temps = useTex treg0

; if ps == null
; 	filter_index = 1718
; endif

; run = CommandListClear

[ShaderRegexMain.Pattern]
(?<header>dcl_output\ho0\.xyzw\n(?:dcl_output\ho1\.xyzw\ndcl_output\ho2\.xyzw\ndcl_output\ho3\.x\ndcl_output\ho4\.x\ndcl_output\ho5\.x\n){0,1}(?!dcl_output)(?:dcl.*\n)*(?:add.*\n(?=ma|sa|lt)(?:(?!sa).*\n)*)|(?:eq.*\n))(?<texture1>(?<texture1head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture1tail>\.\w+.+\n(?<reflectionCheck>ne.*\n){0,1}))(?<doubleside1>(?<doublesplit1>(?:(?!\h*sa).+\n)+)(?<texture1d>(?<texture1dhead>\h+sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture1dtail>\.\w+.+\n\h+add.*\n))){0,1}(?<split>.*\n(?:(?!sa).+\n)+)(?<texture2>(?<texture2head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture2tail>\.\w+.+\n(?!ne.*\nma)))(?<doubleside2>(?<doublesplit2>eq.*\nmul.*\nadd.*\nmad.*\nmovc.+\nif_nz.+\n\h+ne.*\n\h+and.*\n\h+movc.+\n)(?<texture2d>(?<texture2dhead>\h+sample\w+\(\w+\)\((?:float,*){4}\)\hr\d+\.\w+,\hr\d+\.\w+,\h)t\d(?<texture2dtail>\.\w+.+\n))){0,1}(?<nataswap>(?<nataswapsplit1>(?:(?!if.*\n\h+sa).*\n)*if.*\n)(?<natasswapdiffuse>(?<natasswapdiffusehead>\h+sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<natasswapdiffusetail>\.\w+.+\n))(?<nataswapsplit2>(?:(?!sa).*\n)*)(?<natasswaplightmap>(?<natasswaplightmaphead>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<natasswaplightmaptail>\.\w+.+\n))){0,1}

[ShaderRegexMain.InsertDeclarations]
dcl_resource_texture1d (float,float,float,float) t120
dcl_resource_texture2d (float,float,float,float) t100
dcl_resource_texture2d (float,float,float,float) t101
dcl_resource_texture2d (float,float,float,float) t102

[ShaderRegexMain.Pattern.Replace]

${header}

resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t100.xyzw\n
add ${useTex}.x, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.x, l(0.0), ${useTex}.x\n
resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t101.xyzw\n
add ${useTex}.y, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.y, l(0.0), ${useTex}.y\n
resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t102.xyzw\n
add ${useTex}.z, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.z, l(0.0), ${useTex}.z\n

${reflectionCheck:+

	${nataswap:+

		if_nz ${useTex}.z\n
			${texture1head}t102${texture1tail}
		else\n
			${texture1}
		endif\n

	:

		if_nz ${useTex}.y\n
			${texture1head}t101${texture1tail}
		else\n
			${texture1}
		endif\n

	}

:

	if_nz ${useTex}.x\n
		${texture1head}t100${texture1tail}
	else\n
		${texture1}
	endif\n

}

${doubleside1:+

	${doublesplit1}

	if_nz ${useTex}.x\n
		${texture1dhead}t100${texture1dtail}
	else\n
		${texture1d}
	endif\n

}

${split}

${reflectionCheck:+

	if_nz ${useTex}.x\n
		${texture2head}t100${texture2tail}
	else\n
		${texture2}
	endif\n

:

	if_nz ${useTex}.x\n
		${texture2head}t101${texture2tail}
	else\n
		${texture2}
	endif\n

}

${doubleside2:+

	${doublesplit2}

	if_nz ${useTex}.x\n
		${texture2dhead}t100${texture2dtail}
	else\n
		${texture2d}
	endif\n

}

${nataswap:+

	${nataswapsplit1}

	if_nz ${useTex}.x\n
		${natasswapdiffusehead}t100${natasswapdiffusetail}
	else\n
		${natasswapdiffuse}
	endif\n

	${nataswapsplit2}

	if_nz ${useTex}.y\n
		${natasswaplightmaphead}t101${natasswaplightmaptail}
	else\n
		${natasswaplightmap}
	endif\n

}

[ShaderRegexNormal]
shader_model = ps_4_0 ps_5_0
temps = useTex treg0

; if ps == null
; 	filter_index = 1718
; endif

; run = CommandListClear

[ShaderRegexNormal.Pattern]
(?<header>dcl_output\ho0\.xyzw\ndcl_output\ho1\.xyzw\ndcl_output\ho2\.xyzw\ndcl_output\ho3\.x\ndcl_output\ho4\.x\ndcl_output\ho5\.x\n(?:(?!\h+sa).*\n)*)(?<normalmap>(?<normalmaphead>\h+sample\w+\(\w+\)\((?:float,{0,1}){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<normalmaptail>\.\w+.+\n))(?<split>(?:(?!\h+sa.*\n).*\n)*)(?<heightmapR>(?<heightmapRhead>\h+sample\w+\(\w+\)\((?:float,{0,1}){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<heightmapRtail>\.\w+.+\n))(?<splitR>(?:(?!\h+sa.*\n).*\n){0,1})(?<heightmapG>(?<heightmapGhead>\h+sample\w+\(\w+\)\((?:float,{0,1}){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<heightmapGtail>\.\w+.+\n))(?<splitG>(?:(?!\h+sa.*\n).*\n){0,1})(?<heightmapB>(?<heightmapBhead>\h+sample\w+\(\w+\)\((?:float,{0,1}){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<heightmapBtail>\.\w+.+\n))

[ShaderRegexNormal.InsertDeclarations]
dcl_resource_texture1d (float,float,float,float) t120
dcl_resource_texture2d (float,float,float,float) t102

[ShaderRegexNormal.Pattern.Replace]

${header}

resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t102.xyzw\n
add ${useTex}.z, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.z, l(0.0), ${useTex}.z\n

if_nz ${useTex}.z\n
	${normalmaphead}t102${normalmaptail}
else\n
	${normalmap}
endif\n

${split}

if_nz ${useTex}.z\n
	${heightmapRhead}t102${heightmapRtail}
else\n
	${heightmapR}
endif\n

${splitR:+
	${splitR}
}

if_nz ${useTex}.z\n
	${heightmapGhead}t102${heightmapGtail}
else\n
	${heightmapG}
endif\n

${splitG:+
	${splitG}
}

if_nz ${useTex}.z\n
	${heightmapBhead}t102${heightmapBtail}
else\n
	${heightmapB}
endif\n

[ShaderRegexNoLightmap]
shader_model = ps_4_0 ps_5_0
temps = useTex treg0

; if ps == null
; 	filter_index = 1718
; endif

; run = CommandListClear

[ShaderRegexNoLightmap.Pattern]
(?<header>dcl_output\ho0\.xyzw\ndcl_output\ho1\.xyzw\ndcl_output\ho2\.xyzw\ndcl_output\ho3\.x\ndcl_output\ho4\.x\ndcl_output\ho5\.x\n(?:(?!ne).*\n)*ne.*\n(?=if)(?:(?!sa).*\n)*)(?<texture1>(?<texture1head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture1tail>\.\w+.+\n))(?<split1>.*\n(?:(?!\h*sa).+\n)+\h+sample.*\n(?:(?!\h*sa).+\n)+)(?<texture2>(?<texture2head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture2tail>\.\w+.+\n))

[ShaderRegexNoLightmap.InsertDeclarations]
dcl_resource_texture1d (float,float,float,float) t120
dcl_resource_texture2d (float,float,float,float) t100
dcl_resource_texture2d (float,float,float,float) t102

[ShaderRegexNoLightmap.Pattern.Replace]

${header}

resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t100.xyzw\n
add ${useTex}.x, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.x, l(0.0), ${useTex}.x\n
resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t102.xyzw\n
add ${useTex}.z, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.z, l(0.0), ${useTex}.z\n

if_nz ${useTex}.x\n
	${texture1head}t100${texture1tail}
else\n
	${texture1}
endif\n

${split1}

if_nz ${useTex}.y\n
	${texture2head}t102${texture2tail}
else\n
	${texture2}
endif\n


[ShaderRegexWeapon]
shader_model = ps_4_0 ps_5_0
temps = useTex treg0

; if ps == null
; 	filter_index = 1718
; endif

; run = CommandListClear

[ShaderRegexWeapon.Pattern]
(?<header>dcl_output\ho0\.xyzw\ndcl_output\ho1\.xyzw\ndcl_output\ho2\.xyzw\ndcl_output\ho3\.x\ndcl_output\ho4\.x\ndcl_output\ho5\.x\n(?:dcl.*\n)*ne.*\nadd.*\n(?:(?!sa).*\n)*)(?<texture1>(?<texture1head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture1tail>\.\w+.+\n))(?<split1>(?:(?:eq.*\nmul.*\n)|(?<normalcheck>add.*\nmax.*\n))(?:(?!sa).+\n)*)(?<texture2>(?<texture2head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture2tail>\.\w+.+\n(?(normalcheck)(?=div)|(?=ne))))(?(normalcheck)(?:(?<split2>div.*\n(?:(?!sa).*\n)*)(?<texture3>(?<texture3head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture3tail>\.\w+.+\n(?=ne)))))

[ShaderRegexWeapon.InsertDeclarations]
dcl_resource_texture1d (float,float,float,float) t120
dcl_resource_texture2d (float,float,float,float) t100
dcl_resource_texture2d (float,float,float,float) t101
dcl_resource_texture2d (float,float,float,float) t102

[ShaderRegexWeapon.Pattern.Replace]

${header}

resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t100.xyzw\n
add ${useTex}.x, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.x, l(0.0), ${useTex}.x\n
resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t101.xyzw\n
add ${useTex}.y, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.y, l(0.0), ${useTex}.y\n
resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t102.xyzw\n
add ${useTex}.z, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.z, l(0.0), ${useTex}.z\n

${normalcheck:+

	if_nz ${useTex}.z\n
		${texture1head}t102${texture1tail}
	else\n
		${texture1}
	endif\n

	${split1}

	if_nz ${useTex}.x\n
		${texture2head}t100${texture2tail}
	else\n
		${texture2}
	endif\n

	${split2}

	if_nz ${useTex}.y\n
		${texture3head}t101${texture3tail}
	else\n
		${texture3}
	endif\n

:

	if_nz ${useTex}.x\n
		${texture1head}t100${texture1tail}
	else\n
		${texture1}
	endif\n

	${split1}

	if_nz ${useTex}.y\n
		${texture2head}t101${texture2tail}
	else\n
		${texture2}
	endif\n

}

[ShaderRegexTransparent]
shader_model = ps_4_0 ps_5_0
temps = useTex treg0

; if ps == null
; 	filter_index = 1718
; endif

; ps-t0 = ps-t100 unless_null
; ps-t1 = ps-t101 unless_null

; run = CommandListClear

[ShaderRegexTransparent.Pattern]
(?<header>dcl_output\ho0\.xyzw\n(?!dcl_output)(?:dcl.*\n)*)(?<diffuse>(?<diffusehead>sample\w+\(\w+\)\((?:float,{0,1}){4}\)\hr\d\.\w+,\h\w\d+\.\w+,\h)t\d(?<diffusetail>.*\n))(?<split>(?:(?!lt).*\n)*lt.*\nmovc.*\n(?:(?!sa).*\n)*)(?<lightmap>(?<lightmaphead>sample\w+\(\w+\)\((?:float,{0,1}){4}\)\hr\d\.\w+,\h\w\d+\.\w+,\h)t\d(?<lightmaptail>.*\n(?=div)))

[ShaderRegexTransparent.InsertDeclarations]
dcl_resource_texture1d (float,float,float,float) t120
dcl_resource_texture2d (float,float,float,float) t100
dcl_resource_texture2d (float,float,float,float) t101

[ShaderRegexTransparent.Pattern.Replace]

${header}

resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t100.xyzw\n
add ${useTex}.x, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.x, l(0.0), ${useTex}.x\n
resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t101.xyzw\n
add ${useTex}.y, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.y, l(0.0), ${useTex}.y\n

if_nz ${useTex}.x\n
	${diffusehead}t100${diffusetail}
else\n
	${diffuse}
endif\n

${split}

if_nz ${useTex}.y\n
	${lightmaphead}t101${lightmaptail}
else\n
	${lightmap}
endif\n

[ShaderRegexDoubleReflection]
shader_model = ps_4_0 ps_5_0
temps = useTex treg0

; if ps == null
; 	filter_index = 1718
; endif

; ps-t0 = ps-t100 unless_null
; ps-t1 = ps-t101 unless_null

; run = CommandListClear

[ShaderRegexDoubleReflection.Pattern]
(?<header>dcl_output\ho0\.xyzw\n(?!dcl_output)(?:dcl.*\n)*ieq.*\nne.*\n(?:(?!sample).*\n)*)(?<texture1>(?<texture1head>sample\w+\(\w+\)\((?:float,{0,1}){4}\)\hr\d+\.\w+,\h\w\d\.\w+,\h)t\d(?<texture1tail>\.\w+.+\n))(?<split1>eq.*\n(?:(?!\h+sa).*\n)*)(?<texture1d>(?<texture1dhead>\h+sample\w+\(\w+\)\((?:float,{0,1}){4}\)\hr\d+\.\w+,\h\w\d\.\w+,\h)t\d(?<texture1dtail>\.\w+.+\n))(?<split2>\h+add.*\n(?:(?!sa).*\n)*)(?<texture2>(?<texture2head>sample\w+\(\w+\)\((?:float,{0,1}){4}\)\hr\d+\.\w+,\h\w\d\.\w+,\h)t\d(?<texture2tail>\.\w+.+\n))

[ShaderRegexDoubleReflection.InsertDeclarations]
dcl_resource_texture1d (float,float,float,float) t120
dcl_resource_texture2d (float,float,float,float) t100
dcl_resource_texture2d (float,float,float,float) t101

[ShaderRegexDoubleReflection.Pattern.Replace]

${header}

resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t100.xyzw\n
add ${useTex}.x, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.x, l(0.0), ${useTex}.x\n
resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t101.xyzw\n
add ${useTex}.y, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.y, l(0.0), ${useTex}.y\n

if_nz ${useTex}.x\n
	${texture1head}t100${texture1tail}
else\n
	${texture1}
endif\n

${split1}

if_nz ${useTex}.x\n
	${texture1dhead}t100${texture1dtail}
else\n
	${texture1d}
endif\n

${split2}

if_nz ${useTex}.y\n
	${texture2head}t101${texture2tail}
else\n
	${texture2}
endif\n

[ShaderRegexOutline]
shader_model = ps_4_0 ps_5_0
temps = useTex treg0

; if ps == null
; 	filter_index = 1718
; endif

ps-t0 = ps-t100 unless_null
ps-t1 = ps-t101 unless_null

; run = CommandListClear

[ShaderRegexOutline.Pattern]
(?<header>dcl_output\ho0\.xyzw\ndcl_output\ho1\.xyzw\ndcl_output\ho2\.xyzw\ndcl_output\ho3\.x\ndcl_output\ho4\.x\ndcl_output\ho5\.x\n(?:(?!ne).*\n)*ne.*\n(?=if)(?:(?!sa).*\n)*)(?<texture1>(?<texture1head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture1tail>\.\w+.+\neq.*\nadd.*\n))(?<split>(?:.*\n(?:.+\n(?!if))+and.*\nif.*\n\h+sample.*\n){0,1}.*\n(?:(?!\h+sa).+\n)+)(?<texture2>(?<texture2head>\h+sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture2tail>\.\w+.+\n(?=\h+ge.*\n)))

[ShaderRegexOutline.InsertDeclarations]
dcl_resource_texture1d (float,float,float,float) t120
dcl_resource_texture2d (float,float,float,float) t100
dcl_resource_texture2d (float,float,float,float) t101

; [ShaderRegexOutline.Pattern.Replace]

; ${header}

; resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t100.xyzw\n
; add ${useTex}.x, ${treg0}.x, ${treg0}.y\n
; lt ${useTex}.x, l(0.0), ${useTex}.x\n
; resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t101.xyzw\n
; add ${useTex}.y, ${treg0}.x, ${treg0}.y\n
; lt ${useTex}.y, l(0.0), ${useTex}.y\n

; if_nz ${useTex}.x\n
; 	${texture1head}t100${texture1tail}
; else\n
; 	${texture1}
; endif\n

; ${split}

; if_nz ${useTex}.y\n
; 	${texture2head}t101${texture2tail}
; else\n
; 	${texture2}
; endif\n


; Special Nata shaders

[ShaderRegexNataMain]
shader_model = ps_4_0 ps_5_0
temps = useTex treg0

; if ps == null
; 	filter_index = 1718
; endif

; run = CommandListClear

[ShaderRegexNataMain.Pattern]
(?<header>dcl_output\ho0\.xyzw\ndcl_output\ho1\.xyzw\ndcl_output\ho2\.xyzw\ndcl_output\ho3\.x\ndcl_output\ho4\.x\ndcl_output\ho5\.x\n(?:(?!add).*\n)*add.*\n(?=ma|sa|dp)(?:(?!sa).*\n)*)(?<texture1>(?<texture1head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture1tail>\.\w+.+\n(?<reflectionCheck>ne.*\n){0,1}))(?<split1>.*\n(?:(?!sa).+\n)+)(?<texture2>(?<texture2head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture2tail>\.\w+.+\nne.*\nmad.*\n))(?<split2>.*\n(?:(?!sa).+\n)+)(?<texture3>(?<texture3head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture3tail>\.\w+.+\n))(?<doubleside>(?<doublesplit>(?:(?!if).*\n)+if.*\n(?:(?!\h+sa).*\n)*)(?<texture3d>(?<texture3dhead>\h+sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture3dtail>\.\w+.+\n))){0,1}

[ShaderRegexNataMain.InsertDeclarations]
dcl_resource_texture1d (float,float,float,float) t120
dcl_resource_texture2d (float,float,float,float) t100
dcl_resource_texture2d (float,float,float,float) t101
dcl_resource_texture2d (float,float,float,float) t102

[ShaderRegexNataMain.Pattern.Replace]

${header}

resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t100.xyzw\n
add ${useTex}.x, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.x, l(0.0), ${useTex}.x\n
resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t101.xyzw\n
add ${useTex}.y, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.y, l(0.0), ${useTex}.y\n
resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t102.xyzw\n
add ${useTex}.z, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.z, l(0.0), ${useTex}.z\n

if_nz ${useTex}.y\n
	${texture1head}t101${texture1tail}
else\n
	${texture1}
endif\n

${split1}

if_nz ${useTex}.z\n
	${texture2head}t102${texture2tail}
else\n
	${texture2}
endif\n

${split2}

if_nz ${useTex}.x\n
	${texture3head}t100${texture3tail}
else\n
	${texture3}
endif\n

${doubleside:+

	${doublesplit}

	if_nz ${useTex}.x\n
		${texture3dhead}t100${texture3dtail}
	else\n
		${texture3d}
	endif\n

}

[ShaderRegexNataFX]
shader_model = ps_4_0 ps_5_0
temps = useTex treg0

; if ps === null
; 	filter_index = 1718
; endif

; run = CommandListClear

[ShaderRegexNataFX.Pattern]
(?<header>dcl_output\ho0\.xyzw\ndcl_output\ho1\.xyzw\ndcl_output\ho2\.xyzw\ndcl_output\ho3\.x\ndcl_output\ho4\.x\ndcl_output\ho5\.x\n(?:(?!ne).*\n)*ne.*\n(?=if)(?:(?!sa).*\n)*)(?<texture1>(?<texture1head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture1tail>\.\w+.+\n))(?<split1>.*\n(?:(?!\h*sa).+\n)+)(?<texture2>(?<texture2head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture2tail>\.\w+.+\n))(?<notmavuika>(?<split2>.*\n(?:(?!sa).+\n)+)(?<texture3>(?<texture3head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture3tail>\.\w+.+\n))(?<natafx>(?<split3>.*\n(?:(?!sample_l).+\n)+)(?<natafxoutline1>(?<natafxoutline1head>sample_l\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<natafxoutline1tail>\.\w+.+\nmul.*\n))(?<natafxoutline2>(?<natafxoutline2head>sample_l\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<natafxoutline2tail>\.\w+.+\nmul.*\nmul.*\n))(?<natafxtexture>(?<natafxtexturehead>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<natafxtexturetail>\.\w+.+\n))){0,1}){0,1}

[ShaderRegexNataFX.InsertDeclarations]
dcl_resource_texture1d (float,float,float,float) t120
dcl_resource_texture2d (float,float,float,float) t100
dcl_resource_texture2d (float,float,float,float) t101
dcl_resource_texture2d (float,float,float,float) t102
dcl_resource_texture2d (float,float,float,float) t103
dcl_resource_texture2d (float,float,float,float) t104

[ShaderRegexNataFX.Pattern.Replace]

${header}

resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t100.xyzw\n
add ${useTex}.x, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.x, l(0.0), ${useTex}.x\n
resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t101.xyzw\n
add ${useTex}.y, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.y, l(0.0), ${useTex}.y\n
resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t102.xyzw\n
add ${useTex}.z, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.z, l(0.0), ${useTex}.z\n

${notmavuika:+

	if_nz ${useTex}.z\n
		${texture1head}t102${texture1tail}
	else\n
		${texture1}
	endif\n

	${split1}

	if_nz ${useTex}.x\n
		${texture2head}t100${texture2tail}
	else\n
		${texture2}
	endif\n

	${split2}

	if_nz ${useTex}.y\n
		${texture3head}t101${texture3tail}
	else\n
		${texture3}
	endif\n

	${natafx:+

		${split3}

		resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t103.xyzw\n
		add ${useTex}.x, ${treg0}.x, ${treg0}.y\n
		lt ${useTex}.x, l(0.0), ${useTex}.x\n
		resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t104.xyzw\n
		add ${useTex}.y, ${treg0}.x, ${treg0}.y\n
		lt ${useTex}.y, l(0.0), ${useTex}.y\n

		if_nz ${useTex}.x\n
			${natafxoutline1head}t103${natafxoutline1tail}
		else\n
			${natafxoutline1}
		endif\n

		if_nz ${useTex}.x\n
			${natafxoutline2head}t103${natafxoutline2tail}
		else\n
			${natafxoutline2}
		endif\n

		if_nz ${useTex}.y\n
			${natafxtexturehead}t104${natafxtexturetail}
		else\n
			${natafxtexture}
		endif\n

	}

:

	if_nz ${useTex}.x\n
		${texture1head}t100${texture1tail}
	else\n
		${texture1}
	endif\n

	${split1}

	if_nz ${useTex}.y\n
		${texture2head}t101${texture2tail}
	else\n
		${texture2}
	endif\n

}

[ShaderRegexFurinaBurstLODNoLM]
shader_model = ps_4_0 ps_5_0
temps = useTex treg0

[ShaderRegexFurinaBurstLODNoLM.Pattern]
(?<header>dcl_output\ho0\.xyzw\n(?:dcl_output\ho1\.xyzw\ndcl_output\ho2\.xyzw\ndcl_output\ho3\.x\ndcl_output\ho4\.x\ndcl_output\ho5\.x\n){0,1}(?!dcl_output)(?:dcl.*\n)*(?:add.*\n(?=ma|sa|lt)(?:(?!sa).*\n)*)|(?:eq.*\n))(?<texture1>(?<texture1head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture1tail>\.\w+.+\n))(?<doublesplit1>(?:(?!\h*sa).+\n)+)(?<texture1d>(?<texture1dhead>\h+sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture1dtail>\.\w+.+\n\h+add.*\n))(?=.*\n(?:(?!if).+\n)+if.*\n(?:(?!\h+sa)\h+.*\n)*\h+sample_)

[ShaderRegexFurinaBurstLODNoLM.InsertDeclarations]
dcl_resource_texture1d (float,float,float,float) t120
dcl_resource_texture2d (float,float,float,float) t100

[ShaderRegexFurinaBurstLODNoLM.Pattern.Replace]

${header}

resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t100.xyzw\n
add ${useTex}.x, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.x, l(0.0), ${useTex}.x\n

if_nz ${useTex}.x\n
	${texture1head}t100${texture1tail}
else\n
	${texture1}
endif\n

${doublesplit1}

if_nz ${useTex}.x\n
	${texture1dhead}t100${texture1dtail}
else\n
	${texture1d}
endif\n

[ShaderRegexFurinaBurstLODNoNM]
shader_model = ps_4_0 ps_5_0
temps = useTex treg0

[ShaderRegexFurinaBurstLODNoNM.Pattern]
(?<header>dcl_output\ho0\.xyzw\n(?:dcl_output\ho1\.xyzw\ndcl_output\ho2\.xyzw\ndcl_output\ho3\.x\ndcl_output\ho4\.x\ndcl_output\ho5\.x\n){0,1}(?!dcl_output)(?:dcl.*\n)*(?:add.*\n(?=ma|sa|lt)(?:(?!sa).*\n)*)|(?:eq.*\n))(?<texture1>(?<texture1head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture1tail>\.\w+.+\n))(?<split>.*\n(?:(?!sa).+\n)+sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\ht\d\.\w+.+\nne.*\nmad.+\n(?:(?!sa).+\n)+)(?<texture2>(?<texture2head>sample\w+\(\w+\)\((?:\w+,*){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<texture2tail>\.\w+.+\n(?=eq.*\nmul)))

[ShaderRegexFurinaBurstLODNoNM.InsertDeclarations]
dcl_resource_texture1d (float,float,float,float) t120
dcl_resource_texture2d (float,float,float,float) t100
dcl_resource_texture2d (float,float,float,float) t101

[ShaderRegexFurinaBurstLODNoNM.Pattern.Replace]

${header}

resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t100.xyzw\n
add ${useTex}.x, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.x, l(0.0), ${useTex}.x\n
resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t101.xyzw\n
add ${useTex}.y, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.y, l(0.0), ${useTex}.y\n

if_nz ${useTex}.y\n
	${texture1head}t101${texture1tail}
else\n
	${texture1}
endif\n

${split}

if_nz ${useTex}.x\n
	${texture2head}t100${texture2tail}
else\n
	${texture2}
endif\n


[ShaderRegexDoll]
shader_model = ps_4_0 ps_5_0
temps = useTex treg0

; if ps === null
; 	filter_index = 1718
; endif

; run = CommandListClear

[ShaderRegexDoll.Pattern]
(?<header>dcl_output\ho0.xyzw\ndcl_output\ho1.xyzw\ndcl_output\ho2.xyzw\ndcl_output\ho3.x\ndcl_output\ho4.x\ndcl_output\ho5.x\n(?!dcl_output)(?:dcl.*\n)*ne.*\nif.*(?:(?!sa).*\n)*)(?<sample>(?<samplehead>sample_\w_indexable\(\w+\)\((?:float,{0,1}){4}\)\hr\d+\.\w+,\h\w\d+\.\w+,\h)t\d(?<sampletail>\.\w+.+\n(?=sample)))

[ShaderRegexDoll.InsertDeclarations]
dcl_resource_texture1d (float,float,float,float) t120
dcl_resource_texture2d (float,float,float,float) t101

[ShaderRegexDoll.Pattern.Replace]

${header}

resinfo_indexable(texture2d)(float,float,float,float) ${treg0}.xyyy, l(0), t101.xyzw\n
add ${useTex}.y, ${treg0}.x, ${treg0}.y\n
lt ${useTex}.y, l(0.0), ${useTex}.y\n

if_nz ${useTex}.y\n
	${samplehead}t101${sampletail}
else\n
	${sample}
endif\n

[ShaderRegexTempTexFXCompatFix]
shader_model = ps_4_0 ps_5_0
post run = CommandListClear